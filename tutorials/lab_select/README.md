#  Лабораторная работа. Запросы Select 

Цель: сформировать знания и умения по программированию на языке SQL, приобрести практические навыки работы со средствами языка SQL для выборки и редактирования данных в БД. 

## **Краткий вспомогательный материал**

SQL — аббревиатура выражения Structured Query Language (язык структурированных запросов). SQL основывается на реляционной алгебре и специально разработан для взаимодействия с реляционными базами данных. 
 
SQL является, информационно-логическим языком, предназначенным для описания хранимых данных, их извлечения и модификации. SQL не является языком программирования. Конкретные реализации языка, как правило, включают различные процедурные расширения. 
 
Язык SQL представляет собой совокупность операторов, которые можно разделить на четыре группы: 
* DDL (Data Definition Language) - операторы определения данных 
* DML (Data Manipulation Language) – операторы манипуляции данными 
* DCL (Data Control Language) - операторы определения доступа к данным 
* TCL (Transaction Control Language) - операторы управления транзакциями 
SQL является стандартизированным языком. Стандартный SQL поддерживается комитетом стандартов ANSI (Американский национальный институт стандартов), и соответственно называется ANSI SQL. 


# **Оператор SELECT.**
Для выборки данных используется команда: 
```sql
SELECT [ ALL | DISTINCT ] [TOP < выражение > ) [PERCENT]] < список полей > 
FROM < таблица> [ , < таблица2 >...n ] ] 
[ WHERE < условие > ] 
[ GROUP BY < поле > | <Integer> [,...]] [ HAVING < условие >] 
[ ORDER BY < поле > | <Integer> [ ASC|DESC ] [,...]] 
```

Пример. Выбрать все сведения о проектах. 
```sql
SELECT * FROM projects; /* будут выведены все поля */ 
SELECT id, project_name FROM projects; /* будут выведены два поля */ 
```

Рассмотрим отдельные элементы синтаксиса инструкции SELECT. 
* *ALL*  - указывает на то, что в результирующем наборе могут появляться повторяющиеся элементы, является значением по умолчанию.
* *DISTINCT* - в результирующем наборе возвращаются только уникальные результаты.
* *ORDER BY* - cортировка строк результирующей таблицы данных.
Пример. Выбрать сведения о проектах, отсортировав их по названию проекта. 
```sql 
SELECT id, project_name FROM projects 
ORDER BY project; 
```
* *ASC* сортирует данные в восходящем порядке, DESC – в обратном. Вместо имен полей могут быть использованы их порядковые  номера  в  списке  полей результирующей таблицы.
* *TOP* - ограничение количества выбираемых записей в запросе.
Пример. Извлечь из выборки последние пять записей о проектах. 
```sql 
SELECT TOP 5 id, project_name FROM projects ORDER BY DESC; 
-- первые 5    записей из запроса, отсортированного в обратном порядке
```
* *WHERE* - ограничение выборки данных из указанных таблиц.
Пример. Выбрать сведения о сотрудниках, работающих в первом отделе: 
```sql
SELECT * 
FROM employees WHERE id_depart=1; 
```
* *GROUP BY* - объединяет результат запроса в группы. Если внутри GROUP BY используется ORDER BY, то строки сортируются внутри каждой группы результирующих строк.
Пример. Посчитать, сколько заданий в каждом проекте. 
```sql
SELECT id_project, COUNT(*) AS num_tasks /* AS используется для назначения псевдонима столбцу */ 
FROM tasks GROUP BY id_project ; 
```
* *HAVING* - используется вместе с GROUP, для того чтобы выбирать только определенные группы строк данных, которые удовлетворяют указанному условию.
Пример. Вывести сведения о проектах, в которых больше трех заданий. 
```sql
SELECT id_project FROM tasks GROUP BY id_project 
HAVING COUNT(*)>3
```
* *BETWEEN* - проверяет, попадают ли значения проверяемого выражения в диапазон, задаваемый пограничными выражениями, соединяемыми служебным словом AND.
Пример. Выбрать сведения о сотрудниках из первого, второго и третьего отделов. 
```sql
SELECT * FROM employees
WHERE id_depart BETWEEN 1 AND 3;
```
* *IN* - проверяет, попадают ли значения проверяемого выражения во множество
Пример. Выбрать сведения о сотрудниках из первого и третьего отделов. 
```sql
SELECT * FROM employees WHERE id_depar IN(1,3);
```
Пример. Выбрать сведения о сотрудниках из отделов, относящихся к подразделению 3. 
```sql
SELECT * FROM employees WHERE id_depar IN
  (SELECT id_dep from department WHERE dep_branch = 3);
```
* *LIKE* - сравнение строк с шаблоном
Пример. Найти все проекты, названия которых начинаются с буквы А. 
```sql
SELECT * FROM projects WHERE project LIKE 'А%'
```
* *IS [NOT] NULL* - позволяет проверить отсутствие (наличие) значения в полях
Пример. Выбрать сведения о несданных заданиях:
```sql
SELECT * FROM tasks WHERE date_turn IS NULL;
```
* *JOIN* - часто для решения задач необходимо выбирать данные, находящиеся в разных, связанных логически между собой таблицах.
Синтаксис соединения таблиц  имеет вид:
```sql
FROM < таблица1 > [AS < псевдоним_табл1 >] [INNER | LEFT | RIGHT | FULL] JOIN 
< таблица2 > [AS < псевдоним_табл2 >] [ON < предикат >] 
```
Пример.  Вывести номер телефона сотрудника Василькова. 
```sql
SELECT d.phone 
FROM employees JOIN departments as d 
ON(employees.id_depart = d.id_depart) WHERE employees.surname=’Васильков’; 
```
* *Join нескольких таблиц*
Join 2 таблиц ничем не отличается от join'a большего числа таблиц. Для наглядности возьмем следующую структуру бд, на основе которой и пропишем наш join.
```
 categories|   goods      |  orders
 --------- |--------------|-------------
 id(Pk)    |  id(Pk)      |  id(Pk)
 title     |  name        |  items_id
 ----      |  category_id |  num_items
```
Сам запрос будет выглядеть вот так:
```sql
SELECT categories.title, goods.name, goods.id  *Здесь мы выбираем поля из уже объединенной таблицы, которые хотим вывести
  FROM (categories
 INNER JOIN goods
    ON categories.id = goods.category)  *Здесь мы сначала соединяем таблицы категории и товары, а следующим шагом соединим таблицу из этих двух с таблицей заказов
 INNER JOIN orders
    ON orders.items_id = goods.id
 ORDER BY categories.id;    *Собственно присоединяем еще одну таблицу
```

Таким образом объединение нескольких таблиц происходит последовательно. Также при необходимости мы можем добавлять условия WHERE и т.п. Пример:
```sql
SELECT categories.title, goods.name, goods.id  
FROM (categories
INNER JOIN goods
ON categories.id = goods.category WHERE _условие_)  
INNER JOIN orders
ON orders.items_id = goods.id WHERE _условие_  GROUP BY num_items 
ORDER BY categories.id; 
```
* *EXISTS* - принимает значение TRUE, если подзапрос возвращает любое количество строк, иначе его значение равно FALSE.
Пример. Выбрать проекты, которые не выполняются в данный момент. 
```sql
SELECT id_project FROM projects WHERE NOT 
EXISTS (SELECT id FROM tasks)
```
* *UNION*   - выводит результаты двух или более запросов в один результирующий набор. Количество и порядок столбцов должны быть одинаковыми во всех запросах.
Пример. Вывести время выдачи зарплаты сотрудников первого отдела и сотрудников, работающих над проектом «P1» 
```sql
SELECT id_employee, salary_hour FROM employees WHERE id_depart=1 
UNION 
SELECT distinct id_employee, salary_hour 
FROM employees as e join tasks as t on (e.id_employee = t.id_empl) JOIN projects ON (t.id_project=projects.id_project) 
WHERE project= ’P1’ 
ORDER BY salary_hour; 
```
* *Функция  IIF()* - возвращает одно из двух значений в зависимости от того, принимает логическое выражение значение true или false
```sql
IIF ( < boolean_expression >, < true_value >, < false_value > ); 
```
Где:
- boolean_expression - Допустимое логическое выражение. 
- true_value - Возвращаемое значение, если выражение boolean_expression истинно. 
- false_value - Возвращаемое значение, если выражение boolean_expression ложно. 
Пример. Указать занятость сотрудников 
```sql
SELECT id_employee, iif(count(tasks.id)<1,’free’, ’busy’) as busyness 
FROM employees left join tasks on(employees.id_employee = tasks.id_empl) 
WHERE date_turn is NULL /*дата сдачи задания пустая */ 
GROUP BY id_employee; 
/*Результату выполнения функции iif() будет  присвоен псевдоним busyness. */ 
```
# **Варианты:**
| Вариант       | Задание            |
|:-------------:| ------------------ |
| 1-5           | 1. Из таблицы ORDERS выбрать заказы со сроком даты заказа более ранним, чем 20-03-2018. Список отсортировать по номеру заказа в обратном порядке.|
|               | 2. Получить информацию о покупателях, которые не сделали ни одного заказа. Список отсортировать по фамилии.|
| 6-10          | 1. Получить информацию о заказе: id заказа, фамилию, имя, адрес, дата заказа, дата отправки. Список отсортировать так, чтоб заказы, отправленные раньше, выводились в конце.|
|               | 2. Получить  информацию  о  покупателях  (фамилия,  имя,  адрес, телефон), которые оплатили заказ.  Список отсортировать по фамилиям.|
| 11-15         | 1. Получить список заказов от компании «НАЗВАНИЕ КОМПАНИИ». Список отсортировать по дате заказа.|
|               | 2. Получить информацию о покупателях (фамилия, имя, адрес, телефон, город), чьи заказы были отменены. Список отсортировать по городу и фамилиям.|
| 16-20         | 1. Получить информацию о покупателях (компания, фамилия, имя, адрес, телефон, город), которые совершили заказ со статусом «P». Список отсортировать по городу и фамилиям.|
|               | 2. Получить информацию о количестве покупателей в каждом из городов, считать только оплаченные заказы. Список отсортировать по количеству покупателей.|
| 21-25         | 1. Получить список заказов, фамилии, телефоны и адреса покупателей, которые совершили заказ с 11-01-2019 по 20-03- 2019. Список отсортировать по дате заказа.|
|               | 2. Получить информацию о покупателе (фамилия, адрес, телефон, город, дата заказа) с максимальной суммой заказа.|
| 26-30         | 1. Получить информацию о товарах, которые находятся на складе и цена которых от 90 до 1000.  Список отсортировать по цене.|
|               | 2.   Получить информацию о покупателе (фамилия, адрес, телефон, город, дата заказа) с минимальной суммой заказа.|


# **Контрольные вопросы**
1.  Что такое SQL? Предназначение? 
2.  Какие существуют группы операторов в языке SQL? 
3.  Каково назначение команды SELECT? 
4.  Опишите структуру команды SELECT. 
5.  Как осуществляется сортировка? Использование сортировки вместе с группировкой. Прямой и обратный порядок сортировки. 
6.  Как осуществляется ограничение количества выбираемых записей? 
7.  Как реализуется ограничение выбора данных с помощью конструкции WHERE и операторов BETWEEN, IN, LIKE, IS NULL? 
8.  Как осуществляется группировка данных? 
9.  Какие агрегатные функции предусмотрены стандартом? Их назначение. 
10. Как применяется конструкция HAVING BY? 
11. Опишите синтаксис соединения таблиц. 
12. Опишите структуру и принцип работы оператора UNION. 
13. Каково назначение предиката EXIST? 
14. Каково назначении функции IIF? 
