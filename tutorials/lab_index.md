Московский государственный технический университет им. Н.Э. Баумана

Факультет «Искусственный интеллект, иинформатика и системы управления»

Кафедра «Системы обработки информации и управления»

![Изображение выглядит как текст, керамические изделия, фарфор

Автоматически созданное описание](Aspose.Words.77ac8999-e86c-46c4-8367-f12846248966.001.jpeg)

**Лабораторная работа №4** 

**по дисциплине** **«Базы данных»**

**«Индексы и план запроса»**





















Москва, 2022


# **Оглавление**
[Индексы	3](#_Toc121669267)***

[Введение в индексы	3](#_Toc121669268)

[Типы индексов	4](#_Toc121669269)

[Составные индексы	5](#_Toc121669270)

[Объединение нескольких индексов	5](#_Toc121669271)

[Контроль использования индексов	6](#_Toc121669272)

[План запроса	7](#_Toc121669273)

[Введение	7](#_Toc121669274)

[Explain	8](#_Toc121669275)

[Важно	9](#_Toc121669276)

[Примеры	9](#_Toc121669277)

[Ограничения	10](#_Toc121669278)

[Задание	11](#_Toc121669279)

[Контрольные вопросы	11](#_Toc121669280)




# **Индексы**
## **Введение в индексы**
Индексы — это традиционное средство увеличения производительности БД. Используя индекс, сервер баз данных может находить и извлекать нужные строки гораздо быстрее, чем без него. Однако с индексами связана дополнительная нагрузка на СУБД в целом, поэтому применять их следует обдуманно. Предположим, что у нас есть такая таблица: 

`   `CREATE TABLE test1 (

`       `id integer,

`       `content varchar

`   `);

и приложение выполняет много подобных запросов: 

SELECT content FROM test1 WHERE id = константа; 

Если система не будет заранее подготовлена, ей придётся сканировать всю таблицу test1, строку за строкой, чтобы найти все подходящие записи. Когда таблица test1 содержит большое количество записей, а этот запрос должен вернуть всего несколько (возможно, одну или ноль), такое сканирование, очевидно, неэффективно. Но если создать в системе индекс по полю id, она сможет находить строки гораздо быстрее. Возможно, для этого ей понадобится опуститься всего на несколько уровней в дереве поиска. 

Подобный подход часто используется в технической литературе: термины и понятия, которые могут представлять интерес, собираются в алфавитном указателе в конце книги. Читатель может просмотреть этот указатель довольно быстро и затем перейти сразу к соответствующей странице вместо того, чтобы пролистывать всю книгу в поисках нужного материала. Так же, как задача автора предугадать, что именно будут искать в книге читатели, задача программиста баз данных — заранее определить, какие индексы будут полезны. 

Создать индекс для столбца id рассмотренной ранее таблицы можно с помощью следующей команды: 

CREATE INDEX test1\_id\_index ON test1 (id);

Имя индекса test1\_id\_index может быть произвольным, главное, чтобы оно позволяло понять, для чего этот индекс. 

Для удаления индекса используется команда DROP INDEX. Добавлять и удалять индексы можно в любое время. 

Когда индекс создан, никакие дополнительные действия не требуются: система сама будет обновлять его при изменении данных в таблице и сама будет использовать его в запросах, где, по её мнению, это будет эффективнее, чем сканирование всей таблицы. Вам, возможно, придётся только периодически запускать команду ANALYZE для обновления статистических данных, на основе которых планировщик запросов принимает решения.

Индексы могут быть полезны также при выполнении команд UPDATE и DELETE с условиями поиска. Кроме того, они могут применяться в поиске с соединением. То есть, индекс, определённый для столбца, участвующего в условии соединения, может значительно ускорить запросы с JOIN. 

После создания индекса система должна поддерживать его в состоянии, соответствующем данным таблицы. С этим связаны неизбежные накладные расходы при изменении данных. Таким образом, индексы, которые используются в запросах редко или вообще никогда, должны быть удалены. 
## **Типы индексов**
PostgreSQL поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN, BRIN и расширение bloom. Для разных типов индексов применяются разные алгоритмы, ориентированные на определённые типы запросов. По умолчанию команда CREATE INDEX создаёт индексы типа B- дерево, эффективные в большинстве случаев. 

B-деревья могут работать в условиях на равенство и в проверках диапазонов с данными, которые можно отсортировать в некотором порядке. Точнее, планировщик запросов PostgreSQL может задействовать индекс-B-дерево, когда индексируемый столбец участвует в сравнении с одним из следующих операторов: 

- < 
- <=
- = 
- >=
- > 

При обработке конструкций, представимых как сочетание этих операторов, например BETWEEN и IN, так же может выполняться поиск по индексу – B-дереву. Кроме того, такие индексы могут использоваться и в условиях IS NULL и IS NOT NULL по индексированным столбцам. 

Также оптимизатор может использовать эти индексы в запросах с операторами сравнения по шаблону LIKE и ~, *если* этот шаблон определяется константой и он привязан к началу строки — например, col LIKE 'foo%' или col ~ '^foo', но не col LIKE '%bar'.  
## **Составные индексы**
Индексы можно создавать и по нескольким столбцам таблицы. Например, если у вас есть таблица:

`   `CREATE TABLE test2 (

`     `major int,

`     `minor int,

`     `name varchar

);

предположим, что вы часто выполняете запросы вида:

SELECT name FROM test2 WHERE major = константа AND minor = константа;

тогда имеет смысл определить индекс, покрывающий оба столбца major и minor. Например:

CREATE INDEX test2\_mm\_idx ON test2 (major, minor);

В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Число столбцов в индексе ограничивается 32. 
## **Объединение нескольких индексов**
При простом сканировании индекса могут обрабатываться только те предложения в запросе, в которых применяются операторы его класса и объединяет их AND. Например, для индекса (a, b) условие запроса WHERE a = 5 AND b = 6 сможет использовать этот индекс, а запрос WHERE a = 5 OR b = 6 — нет.

К счастью, PostgreSQL способен соединять несколько индексов (и в том числе многократно применять один индекс) и охватывать также случаи, когда сканирования одного индекса недостаточно. Система может сформировать условия AND и OR за несколько проходов индекса. Например, запрос WHERE x = 42 OR x = 47 OR x = 53 OR x = 99 можно разбить на четыре сканирования индекса по x, по сканированию для каждой части условия. Затем результаты этих сканирований будут логически сложены (OR) вместе и дадут конечный результат. Другой пример — если у нас есть отдельные индексы по x и y, запрос WHERE x = 5 AND y = 6 можно выполнить, применив индексы для соответствующих частей запроса, а затем вычислив логическое произведение (AND) для найденных строк, которое и станет конечным результатом.

Выполняя объединение нескольких индексов, система сканирует все необходимые индексы и создаёт в памяти битовую карту расположения строк таблицы, которые удовлетворяют условиям каждого индекса. Затем битовые карты объединяются операциями AND и OR, как того требуют условия в запросе. Наконец система обращается к соответствующим отмеченным строкам таблицы и возвращает их данные. Строки таблицы просматриваются в физическом порядке, как они представлены в битовой карте; это означает, что порядок сортировки индексов при этом теряется и в запросах с предложением ORDER BY сортировка будет выполняться отдельно. По этой причине, а также потому, что каждое сканирование индекса занимает дополнительное время, планировщик иногда выбирает простое сканирование индекса несмотря на то, что можно было бы подключить и дополнительные индексы.
## **Контроль использования индексов**
Хотя индексы в PostgreSQL не требуют какого-либо обслуживания или настройки, это не избавляет от необходимости проверять, как и какие индексы используются на самом деле в реальных условиях. Узнать, как отдельный запрос использует индексы, можно с помощью команды EXPLAIN; её применение для этих целей описывается ниже. 

Вывести универсальную формулу, определяющую, какие индексы нужно создавать, довольно сложно, если вообще возможно. В предыдущих разделах рассматривались некоторые типовые ситуации, иллюстрирующие подходы к этому вопросу. Часто найти ответ на него помогают эксперименты. Ниже приведены ещё несколько советов:

- Всегда начинайте исследование с ANALYZE. Эта команда собирает статистические данные о распределении значений в таблице, которые необходимы для оценивания числа строк, возвращаемых запросов. А это число, в свою очередь, нужно планировщику, чтобы оценить реальные затраты для всевозможных планов выполнения запроса. Не имея реальной статистики, планировщик будет вынужден принять некоторые значения по умолчанию, которые почти наверняка не будут соответствовать действительности. Поэтому понять, как индекс используется приложением без предварительного запуска ANALYZE, практически невозможно
- Используйте в экспериментах реальные данные. Анализируя работу системы с тестовыми данными, вы поймёте, какие индексы нужны для тестовых данных, но не более того.
- Когда индексы не используются, ради тестирования может быть полезно подключить их принудительно. 
- Если система начинает использовать индекс только под принуждением, тому может быть две причины: либо система права и применять индекс в самом деле неэффективно, либо оценка стоимости применения индекса не соответствует действительности. В этом случае вам следует замерить время выполнения запроса с индексами и без них. В анализе этой ситуации может быть полезна команда EXPLAIN ANALYZE.
- Если выясняется, что оценка стоимости неверна, это может иметь тоже два объяснения. Общая стоимость вычисляется как произведение цены каждого узла плана для одной строки и оценки избирательности узла плана. Цены узлов при необходимости можно изменить параметрами выполнения. С другой стороны, оценка избирательности может быть неточной из-за некачественной статистики. Улучшить её можно, настроив параметры сбора статистики.
  Если ваши попытки скорректировать стоимость планов не увенчаются успехом, возможно вам останется только явно заставить систему использовать нужный индекс.
# **План запроса**
## **Введение**
Выполняя любой полученный запрос, Postgres Pro разрабатывает для него план запроса. Выбор правильного плана, соответствующего структуре запроса и характеристикам данным, крайне важен для хорошей производительности, поэтому в системе работает сложный планировщик, задача которого — подобрать хороший план. Узнать, какой план был выбран для какого-либо запроса, можно с помощью команды EXPLAIN. Понимание плана — это искусство, и чтобы овладеть им, нужен определённый опыт, но этот раздел расскажет о самых простых вещах.
## **Explain**
EXPLAIN — показать план выполнения оператора

EXPLAIN [ ( ***параметр*** [, ...] ) ] ***оператор***

Здесь допускается ***параметр***:

`    `ANALYZE [ ***boolean*** ]

`    `VERBOSE [ ***boolean*** ]

`    `COSTS [ ***boolean*** ]

`    `BUFFERS [ ***boolean*** ]

`    `TIMING [ ***boolean*** ]

`    `FORMAT { TEXT | XML | JSON | YAML }

Эта команда выводит план выполнения, генерируемый планировщиком Postgres Pro для заданного оператора. План выполнения показывает, как будут сканироваться таблицы, затрагиваемые оператором — просто последовательно, по индексу и т. д. — а если запрос связывает несколько таблиц, какой алгоритм соединения будет выбран для объединения считанных из них строк.

Наибольший интерес в выводимой информации представляет ожидаемая стоимость выполнения оператора, которая показывает, сколько, по мнению планировщика, будет выполняться этот оператор (это значение измеряется в единицах стоимости, которые не имеют точного определения, но обычно это обращение к странице на диске). Фактически выводятся два числа: стоимость запуска до выдачи первой строки и общая стоимость выдачи всех строк. Для большинства запросов важна общая стоимость, но в таких контекстах, как подзапрос в EXISTS, планировщик будет минимизировать стоимость запуска, а не общую стоимость (так как исполнение запроса всё равно завершится сразу после получения одной строки). Кроме того, если количество возвращаемых строк ограничивается предложением LIMIT, планировщик интерполирует стоимость между двумя этими числами, выбирая наиболее выгодный план.

С параметром ANALYZE оператор будет выполнен на самом деле, а не только запланирован. При этом в вывод добавляются фактические сведения о времени выполнения, включая общее время, затраченное на каждый узел плана (в миллисекундах) и общее число строк, выданных в результате. Это помогает понять, насколько близки к реальности предварительные оценки планировщика.
### **Важно**
Имейте в виду, что с указанием ANALYZE оператор действительно выполняется. Хотя EXPLAIN отбрасывает результат, который вернул бы SELECT, в остальном все действия выполняются как обычно. Если вы хотите выполнить EXPLAIN ANALYZE с командой INSERT, UPDATE, DELETE, CREATE TABLE AS или EXECUTE, не допуская изменения данных этой командой, воспользуйтесь таким приёмом:

BEGIN;

EXPLAIN ANALYZE ...;

ROLLBACK;

Без скобок для этого оператора можно указать только параметры ANALYZE и VERBOSE и только в таком порядке. В PostgreSQL до версии 9.0 поддерживался только синтаксис без скобок, однако в дальнейшем ожидается, что все новые параметры будут восприниматься только в скобках.
### **Примеры**
Простейший пример

EXPLAIN SELECT \* FROM tenk1;

`                         `QUERY PLAN

\-------------------------------------------------------------

` `Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)

Если в таблице есть отдельные индексы по разным столбцам, фигурирующим в WHERE, планировщик может выбрать сочетание этих индексов (с AND и OR): 

EXPLAIN SELECT \* FROM tenk1 WHERE unique1 < 100 AND unique2 > 9000;

`                                     `QUERY PLAN

\-------------------------------------------------------------------------------------

` `Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244)

`   `Recheck Cond: ((unique1 < 100) AND (unique2 > 9000))

`   `->  BitmapAnd  (cost=25.08..25.08 rows=10 width=0)

`         `->  Bitmap Index Scan on tenk1\_unique1  (cost=0.00..5.04 rows=101 width=0)

`               `Index Cond: (unique1 < 100)

`         `->  Bitmap Index Scan on tenk1\_unique2  (cost=0.00..19.78 rows=999 width=0)

`               `Index Cond: (unique2 > 9000)

С методом ANALYZE

EXPLAIN ANALYZE SELECT \*

FROM tenk1 t1, tenk2 t2

WHERE t1.unique1 < 10 AND t1.unique2 = t2.unique2;

`                                                           `QUERY PLAN

\---------------------------------------------------------------------------------------------------------------------------------

` `Nested Loop  (cost=4.65..118.62 rows=10 width=488) (actual time=0.128..0.377 rows=10 loops=1)

`   `->  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244) (actual time=0.057..0.121 rows=10 loops=1)

`         `Recheck Cond: (unique1 < 10)

`         `->  Bitmap Index Scan on tenk1\_unique1  (cost=0.00..4.36 rows=10 width=0) (actual time=0.024..0.024 rows=10 loops=1)

`               `Index Cond: (unique1 < 10)

`   `->  Index Scan using tenk2\_unique2 on tenk2 t2  (cost=0.29..7.91 rows=1 width=244) (actual time=0.021..0.022 rows=1 loops=10)

`         `Index Cond: (unique2 = t1.unique2)

` `Planning time: 0.181 ms

` `Execution time: 0.501 ms

## **Ограничения**
Время выполнения, измеренное командой EXPLAIN ANALYZE, может значительно отличаться от времени выполнения того же запроса в обычном режиме. Тому есть две основных причины. Во-первых, так как при анализе никакие строки результата не передаются клиенту, время ввода/вывода и передачи по сети не учитывается. Во-вторых, может быть существенной дополнительная нагрузка, связанная с функциями измерений EXPLAIN ANALYZE.
# **Задание**
1. Создать таблице по вашей теме
1. Выполнить к ней запрос и вывести его план
1. Создать индекс на этой таблице, так чтобы запрос предидущего использовал индекс
1. Выполнить к ней запрос из шага 2 и вывести его план
# **Контрольные вопросы**
1. Что такое индекс и как его создать?
1. Какие типы индексов бывают?
1. С какими условиями могут работать B-деревья?
1. Может ли индекс быть составным и если да, то как его создать?
1. Как PostgreSQL объединяет индексы?
1. Что такое план запроса и какие у него параметры?
1. За что отвечает параметр ANALYZE?
2

